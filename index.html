<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WrongMaps â€” Useless GPS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    body {
      font-family: 'Comic Sans MS', cursive, sans-serif;

      /* Animated rainbow background */
      background: linear-gradient(270deg, 
        red, orange, yellow, green, blue, indigo, violet, red);
      background-size: 1400% 1400%;
      animation: rainbowBackground 20s ease infinite;
      color: #222; /* text color for contrast */
      transition: color 0.3s ease;
    }

    @keyframes rainbowBackground {
      0% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
      100% {
        background-position: 0% 50%;
      }
    }

    .app-header { 
      background: linear-gradient(135deg, #ff5f6d, #ffc371); 
      color: white; 
      padding: 15px; 
      text-align: center; 
      font-weight: bold; 
      font-size: 1.3em;
      letter-spacing: 0.5px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15); 
    }

    #map { 
      height: calc(100vh - 440px); 
      border-radius: 12px; 
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    .info-panel { 
      border-radius: 10px; 
      padding: 12px 15px; 
      margin-top: 10px; 
      font-size: 14px; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.08); 
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      background: white; /* to keep info panels readable */
      color: #222;
    }
    .info-panel:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    #tripSummary { font-size: 1.15em; }
    #trafficPanel { background: #fff3cd; }
    #poiPanel { background: #e8f5e9; }
    #navPanel { background: #e3f2fd; font-size: 1.05em; font-weight: bold; }
    #weatherPanel { background: #d1c4e9; }
    #achievementPanel { background: #f8bbd0; }

    .btn-prank { 
      background: linear-gradient(135deg, #ff5f6d, #ffc371); 
      border: none; 
      color: white; 
      font-weight: bold; 
      transition: opacity 0.2s ease;
    }
    .btn-prank:hover { 
      opacity: 0.9; 
    }

    .progress { 
      height: 15px; 
      margin-top: 5px; 
      border-radius: 10px;
      overflow: hidden;
    }

    .travel-modes {
      background:#fff;
      padding: 10px;
      border-radius: 10px;
      margin-bottom: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      color: #222;
    }

    #instructions {
      font-size: 0.9em;
      color: #555;
      margin-bottom: 8px;
    }

    body.theme-dark {
      background: #121212;
      color: #ddd;
    }
    body.theme-dark header {
      background-color: rgba(30, 30, 30, 0.95);
      border-bottom: 4px dashed #ff66cc;
      color: #eee;
    }
    body.theme-dark .badge {
      background-color: rgba(50, 50, 50, 0.9);
      box-shadow: 0 4px 10px rgba(255, 255, 255, 0.1);
      border-color: #ff66cc;
      color: #eee;
    }
    body.theme-dark .unlock-btn {
      background: #cc99ff;
      color: #111;
    }
    body.theme-dark .unlock-btn:hover {
      background: #b377ff;
    }
    body.theme-dark .self-destruct-btn {
      background: #ff6666;
      color: #111;
    }
    body.theme-dark .self-destruct-btn:hover {
      background: #cc3333;
    }
    body.theme-dark #loadingBar {
      background: #cc99ff;
    }
  </style>
</head>
<body>
  
  <div class="app-header">ğŸš— NotGoogleMaps â€” Welcome, <span id="username">Guest</span></div>
  <nav class="navbar navbar-light bg-light mb-3"></nav>

  <div class="container mt-3">
    <div class="card shadow-sm p-3 border-0">
      <div class="row g-2">
        <div class="col-md-5">
          <input id="start" class="form-control" placeholder="Start: Place or lat,lng">
        </div>
        <div class="col-md-5">
          <input id="dest" class="form-control" placeholder="Destination: Place or lat,lng">
        </div>
        <div class="col-md-2">
          <button id="routeBtn" class="btn btn-prank w-100">ğŸ¯ Prank Route</button>
        </div>
      </div>
      <small class="text-muted mt-2 d-block">
        âš  Simulation only â€” Do not use for real navigation.
      </small>
    </div>
  </div>

  <div class="container mt-3">

    <div class="travel-modes">
      <b>Travel Modes:</b><br>
      <button class="btn btn-sm btn-outline-primary m-1" onclick="setMode('driving')">ğŸš— Driving</button>
      <button class="btn btn-sm btn-outline-success m-1" onclick="setMode('walking')">ğŸš¶ Walking</button>
      <button class="btn btn-sm btn-outline-warning m-1" onclick="setMode('cycling')">ğŸš´ Cycling</button>
      <button class="btn btn-sm btn-outline-secondary m-1" onclick="setMode('train')">ğŸš† Train</button>
    </div>
     
    <div class="container mt-2 text-end">
      <a href="history.html" class="btn btn-outline-secondary btn-sm">ğŸ“œ Saved Routes</a>
      <a href="settings.html" class="btn btn-outline-secondary btn-sm">âš™ï¸ Settings</a>
      <a href="achievements.html" class="btn btn-outline-secondary btn-sm">ğŸ… Achievements</a>
      <a href="leaderboard.html" class="btn btn-outline-secondary btn-sm">ğŸ“Š Leaderboard</a>
    </div>
        
    <div id="multiModePanel" class="info-panel">
      <b>All Mode Summary:</b> Click a travel mode to view estimates.
    </div>

    <div id="instructions">Click on the map to add waypoints. Drag markers to move them. Click markers to remove waypoints.</div>
    <div id="map"></div>
  </div>

  <div class="container mt-3">
    <div id="tripSummary" class="info-panel"><b>Trip Summary:</b> Waiting for route...</div>
    <div class="progress"><div id="routeProgress" class="progress-bar bg-danger" style="width: 0%"></div></div>
    <div id="trafficPanel" class="info-panel">ğŸš§ Fake traffic info will appear here.</div>
    <div id="poiPanel" class="info-panel">ğŸ“ Points of interest will appear here.</div>
    <div id="navPanel" class="info-panel">ğŸ§­ Navigation will appear here.</div>
    <div id="weatherPanel" class="info-panel">ğŸŒ¦ Weather info will appear here.</div>
    <div id="achievementPanel" class="info-panel">ğŸ… Achievements will appear here.</div>
  </div>

  <!-- Prank music audio element -->
  <audio id="prankAudio" loop>
    <source src="https://cdn.pixabay.com/download/audio/2022/03/23/audio_3f6e7b49e0.mp3?filename=fun-funky-ambient-116963.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    let currentMode = 'driving';
    let waypoints = []; // {latlng, marker}
    let polyLayers = [];

    if (!localStorage.getItem('wrongmapsUser')) {
      window.location.href = 'loginpage.html';
    } else {
      document.getElementById("username").innerText = localStorage.getItem('wrongmapsUser');
    }

    const map = L.map('map').setView([28.6139,77.2090], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

    // Parse lat,lng from string
    function parseLatLng(s) {
      if (!s) return null;
      const [lat, lng] = s.split(',').map(x => parseFloat(x.trim()));
      return (isNaN(lat) || isNaN(lng)) ? null : [lat, lng];
    }

    async function geocodePlace(placeName) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(placeName)}`;
      const res = await fetch(url);
      const data = await res.json();
      if (data.length === 0) throw new Error(`No results for "${placeName}"`);
      return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
    }

    async function reverseGeocode(lat, lng) {
      const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Reverse geocoding failed");
      const data = await res.json();
      return data.display_name || `${lat.toFixed(3)}, ${lng.toFixed(3)}`;
    }

    // Add waypoint with draggable marker
    function addWaypoint(latlng) {
      const marker = L.marker(latlng, { draggable: true }).addTo(map);
      waypoints.push({ latlng, marker });

      marker.on('dragend', () => {
        updateWaypointPosition(marker);
        updateRoute();
      });

      marker.on('click', () => {
        removeWaypoint(marker);
        updateRoute();
      });
      updateRoute();
    }

    function updateWaypointPosition(marker) {
      const wp = waypoints.find(wp => wp.marker === marker);
      if (wp) wp.latlng = marker.getLatLng();
    }

    function removeWaypoint(marker) {
      const index = waypoints.findIndex(wp => wp.marker === marker);
      if (index !== -1) {
        map.removeLayer(waypoints[index].marker);
        waypoints.splice(index, 1);
      }
    }

    // Generate wrong destination offset for prank
    function getWrongDestination(originalDest) {
      const offsetLat = (Math.random() - 0.5) * 2;
      const offsetLng = (Math.random() - 0.5) * 2;
      return [originalDest[0] + offsetLat, originalDest[1] + offsetLng];
    }

    // Fetch routes from OSRM API (multi-waypoint supported)
    async function fetchRouteMultiMode(points, mode) {
      if (mode === 'train') {
        // Fake train calculation for multi-waypoints
        const fakeDuration = Math.floor(Math.random() * 5) + 6; // hours
        const fakeDistance = Math.floor(Math.random() * 800) + 200; // km
        return {
          fake: true,
          duration: fakeDuration * 3600,
          distance: fakeDistance * 1000,
          geometry: null
        };
      }
      if (points.length < 2) throw new Error("Add at least 2 waypoints for routing.");

      const coordsStr = points.map(p => `${p[1]},${p[0]}`).join(';');
      const url = `https://router.project-osrm.org/route/v1/${mode}/${coordsStr}?overview=full&geometries=geojson`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Routing service error for ${mode}`);
      const data = await res.json();
      return {
        fake: false,
        duration: data.routes[0].duration,
        distance: data.routes[0].distance,
        geometry: data.routes[0].geometry
      };
    }

    // Draw route polyline on map
    function drawRoute(data) {
      polyLayers.forEach(l => map.removeLayer(l));
      polyLayers = [];
      if (!data.geometry) return;
      const coords = data.geometry.coordinates.map(c => [c[1], c[0]]);
      const poly = L.polyline(coords, { color: 'red', weight: 5, dashArray: '10, 10' }).addTo(map);
      polyLayers.push(poly);
      map.fitBounds(poly.getBounds());
    }

    // Update trip summary panel
    function updateTripSummary(route, destName) {
      const totalSeconds = route.duration; // in seconds
      const absurdTimeMs = totalSeconds * 1000;
      const fakeParsecs = (totalSeconds / 3600) * 0.000000001;
      const distanceKm = (route.distance / 1000).toFixed(1);

      document.getElementById('tripSummary').innerHTML =
        `<b>Trip Summary:</b> ${absurdTimeMs.toLocaleString()} milliseconds ` +
        `(${fakeParsecs.toFixed(9)} parsecs) â€” Distance: ${distanceKm} km` +
        `<br><b>Heading to:</b> ${destName}`;

      fakeProgress();
    }

    // Show fake navigation steps
    function showFakeNavigation() {
      const messages = [
        "In 40m, turn left into a lake.",
        "Continue straight for 1,342 km.",
        "Stop for coffee at the next roundabout.",
        "Turn rightâ€¦ eventually.",
        "Make a U-turn and question your life choices.",
        "Proceed until you see a cow, then turn left.",
        "You have arrivedâ€¦ probably.",
        "Drive through the shopping mall, it's faster."
      ];
      let steps = [];
      for (let i = 0; i < 5; i++) { 
        steps.push(messages[Math.floor(Math.random() * messages.length)]); 
      }
      document.getElementById('navPanel').innerHTML = steps.join("<br>");
    }

    function saveCurrentRoute() {
      if (waypoints.length < 2) return;
      const start = [waypoints[0].latlng.lat, waypoints[0].latlng.lng];
      const destination = [waypoints[waypoints.length - 1].latlng.lat, waypoints[waypoints.length - 1].latlng.lng];
      const timestamp = Date.now();

      const routes = JSON.parse(localStorage.getItem('wrongmapsSavedRoutes')) || [];
      routes.push({ start, destination, mode: currentMode, timestamp });
      localStorage.setItem('wrongmapsSavedRoutes', JSON.stringify(routes));
    }

    // Fake progress bar animation
    function fakeProgress() {
      let progress = 0;
      const bar = document.getElementById('routeProgress');
      bar.style.width = "0%";
      const interval = setInterval(() => {
        if (progress >= 100) { clearInterval(interval); }
        progress += Math.floor(Math.random() * 5) + 1;
        bar.style.width = Math.min(progress, 100) + "%";
      }, 500);
    }

    function showFakeTraffic() {
      const alerts = [
        "ğŸš§ Heavy snail traffic ahead.",
        "ğŸ¦† Ducks crossing â€” expect 45 min delay.",
        "ğŸ”¥ Road on fire â€” scenic detour.",
        "ğŸ’ƒ Flash mob blocking main street.",
        "ğŸ˜ Elephant parade in progress.",
        "ğŸ“¸ Speed camera ahead â€” smile!"
      ];
      document.getElementById('trafficPanel').innerHTML = alerts[Math.floor(Math.random() * alerts.length)];
    }

    function showFakePOIs() {
      const pois = [
        "World's Largest Pothole",
        "Statue of a Guy Eating Noodles",
        "Haunted Restroom",
        "Invisible Bridge",
        "The Great Sandpit"
      ];
      let list = "";
      for (let i = 0; i < 3; i++) { 
        list += `â€¢ ${pois[Math.floor(Math.random() * pois.length)]}<br>`; 
      }
      document.getElementById('poiPanel').innerHTML = list;
    }

    function showFakeWeather() {
      const weather = [
        "â˜€ Sunny, 35Â°C",
        "ğŸŒ§ Heavy rain, 12Â°C",
        "â›ˆ Thunderstorm, 20Â°C",
        "â„ Snowstorm, -5Â°C",
        "ğŸŒª Tornado Watch"
      ];
      document.getElementById('weatherPanel').innerHTML = `<b>Weather at Destination:</b> ${weather[Math.floor(Math.random() * weather.length)]}`;
    }

    function showAchievements() {
      const badges = [
        "ğŸ† Master of Wrong Turns",
        "ğŸ¥‡ Lost in Style",
        "ğŸš¦ Red Light Runner (in dreams)",
        "ğŸ—º Route Rebel"
      ];
      document.getElementById('achievementPanel').innerHTML = `<b>Driver Achievements:</b><br>${badges[Math.floor(Math.random() * badges.length)]}`;
    }

    // Mode setter with button highlight
    function setMode(mode) {
      currentMode = mode;
      updateRoute();
    }

    // Core update route function, with reverse geocode for prank destination
    async function updateRoute() {
      if (waypoints.length < 2) {
        document.getElementById('tripSummary').innerHTML = "<b>Trip Summary:</b> Add at least two points.";
        polyLayers.forEach(l => map.removeLayer(l));
        polyLayers = [];
        return;
      }

      const coords = waypoints.map(wp => [wp.latlng.lat, wp.latlng.lng]);
      const start = coords[0];
      const originalDest = coords[coords.length - 1];
      const prankDest = getWrongDestination(originalDest);

      try {
        // Get place name for prank destination
        const prankDestName = await reverseGeocode(prankDest[0], prankDest[1]);

        // Calculate prank route (except train is fake)
        const prankRoute = await fetchRouteMultiMode(
          [start, prankDest],
          currentMode === 'train' ? 'driving' : currentMode
        );

        // Calculate real route
        const realRoute = await fetchRouteMultiMode(coords, currentMode);

        drawRoute(prankRoute);

        updateTripSummary(prankRoute, prankDestName);

        showFakeNavigation();
        showFakeTraffic();
        showFakePOIs();
        showFakeWeather();
        showAchievements();

        saveCurrentRoute();

      } catch (e) {
        document.getElementById('tripSummary').innerHTML = "<b>Trip Summary:</b> " + e.message;
      }
    }

    // When user clicks map, add waypoint
    map.on('click', (e) => {
      addWaypoint(e.latlng);
    });

    document.getElementById('routeBtn').addEventListener('click', () => {
      // Clear existing waypoints
      waypoints.forEach(wp => map.removeLayer(wp.marker));
      waypoints = [];

      // Read inputs, parse them to coordinates or geocode
      Promise.all([
        parseInputToLatLng(document.getElementById('start').value),
        parseInputToLatLng(document.getElementById('dest').value)
      ]).then(([startCoords, destCoords]) => {
        if (!startCoords || !destCoords) {
          alert("Please enter valid start and destination.");
          return;
        }
        addWaypoint(L.latLng(startCoords[0], startCoords[1]));
        addWaypoint(L.latLng(destCoords[0], destCoords[1]));
      }).catch(err => alert("Error parsing locations: " + err.message));
    });

    // Helper: parse input (lat,lng) or geocode place
    async function parseInputToLatLng(input) {
      if (!input.trim()) return null;
      const latlng = parseLatLng(input);
      if (latlng) return latlng;
      return await geocodePlace(input);
    }

  </script>
</body>
</html>
