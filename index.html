<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WrongMaps â€” Useless GPS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    body { 
      background: #f4f6f9; 
      font-family: 'Segoe UI', Tahoma, sans-serif; 
    }

    .app-header { 
      background: linear-gradient(135deg, #ff5f6d, #ffc371); 
      color: white; 
      padding: 15px; 
      text-align: center; 
      font-weight: bold; 
      font-size: 1.3em;
      letter-spacing: 0.5px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15); 
    }

    #map { 
      height: calc(100vh - 440px); 
      border-radius: 12px; 
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    .info-panel { 
      border-radius: 10px; 
      padding: 12px 15px; 
      margin-top: 10px; 
      font-size: 14px; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.08); 
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .info-panel:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    #tripSummary { background: #ffffff; font-size: 1.15em; }
    #trafficPanel { background: #fff3cd; }
    #poiPanel { background: #e8f5e9; }
    #navPanel { background: #e3f2fd; font-size: 1.05em; font-weight: bold; }
    #weatherPanel { background: #d1c4e9; }
    #achievementPanel { background: #f8bbd0; }

    .btn-prank { 
      background: linear-gradient(135deg, #ff5f6d, #ffc371); 
      border: none; 
      color: white; 
      font-weight: bold; 
      transition: opacity 0.2s ease;
    }
    .btn-prank:hover { 
      opacity: 0.9; 
    }

    .progress { 
      height: 15px; 
      margin-top: 5px; 
      border-radius: 10px;
      overflow: hidden;
    }

    .travel-modes {
      background:#fff;
      padding: 10px;
      border-radius: 10px;
      margin-bottom: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    #instructions {
      font-size: 0.9em;
      color: #555;
      margin-bottom: 8px;
    }
    body.theme-dark {
  background: #121212;
  color: #ddd;
}
body.theme-dark header {
  background-color: rgba(30, 30, 30, 0.95);
  border-bottom: 4px dashed #ff66cc;
  color: #eee;
}
body.theme-dark .badge {
  background-color: rgba(50, 50, 50, 0.9);
  box-shadow: 0 4px 10px rgba(255, 255, 255, 0.1);
  border-color: #ff66cc;
  color: #eee;
}
body.theme-dark .unlock-btn {
  background: #cc99ff;
  color: #111;
}
body.theme-dark .unlock-btn:hover {
  background: #b377ff;
}
body.theme-dark .self-destruct-btn {
  background: #ff6666;
  color: #111;
}
body.theme-dark .self-destruct-btn:hover {
  background: #cc3333;
}
body.theme-dark #loadingBar {
  background: #cc99ff;
}

  body {
    font-family: 'Comic Sans MS', cursive, sans-serif;
  }



  </style>
</head>
<body>
  
  <div class="app-header">ğŸš— NotGoogleMaps â€” Welcome, <span id="username">Guest</span></div>
  <nav class="navbar navbar-light bg-light mb-3">

</nav>

  <div class="container mt-3">
    <div class="card shadow-sm p-3 border-0">
      <div class="row g-2">
        <div class="col-md-5">
          <input id="start" class="form-control" placeholder="Start: Place or lat,lng">
        </div>
        <div class="col-md-5">
          <input id="dest" class="form-control" placeholder="Destination: Place or lat,lng">
        </div>
        <div class="col-md-2">
          <button id="routeBtn" class="btn btn-prank w-100">ğŸ¯ Prank Route</button>
          
        </div>
      </div>
      <small class="text-muted mt-2 d-block">
        âš  Simulation only â€” Do not use for real navigation.
      </small>
    </div>
  </div>

  <div class="container mt-3">

    <div class="travel-modes">
      <b>Travel Modes:</b><br>
      <button class="btn btn-sm btn-outline-primary m-1" onclick="setMode('driving')">ğŸš— Driving</button>
      <button class="btn btn-sm btn-outline-success m-1" onclick="setMode('walking')">ğŸš¶ Walking</button>
      <button class="btn btn-sm btn-outline-warning m-1" onclick="setMode('cycling')">ğŸš´ Cycling</button>
      <button class="btn btn-sm btn-outline-secondary m-1" onclick="setMode('train')">ğŸš† Train</button>
    </div>
     
    <div class="container mt-2 text-end">
  <a href="history.html" class="btn btn-outline-secondary btn-sm">ğŸ“œ Saved Routes</a>
<a href="settings.html" class="btn btn-outline-secondary btn-sm">âš™ï¸ Settings</a>
<a href="achievements.html" class="btn btn-outline-secondary btn-sm">âš™ï¸ Achievements</a>
<a href="leaderboard.html" class="btn btn-outline-secondary btn-sm">âš™ï¸ Leaderboard</a>

</div>
        


    <div id="multiModePanel" class="info-panel">
      <b>All Mode Summary:</b> Click a travel mode to view estimates.
    </div>

    <div id="instructions">Click on the map to add waypoints. Drag markers to move them. Click markers to remove waypoints.</div>
    <div id="map"></div>
  </div>

  <div class="container mt-3">
    <div id="tripSummary" class="info-panel"><b>Trip Summary:</b> Waiting for route...</div>
    <div class="progress"><div id="routeProgress" class="progress-bar bg-danger" style="width: 0%"></div></div>
    <div id="trafficPanel" class="info-panel">ğŸš§ Fake traffic info will appear here.</div>
    <div id="poiPanel" class="info-panel">ğŸ“ Points of interest will appear here.</div>
    <div id="navPanel" class="info-panel">ğŸ§­ Navigation will appear here.</div>
    <div id="weatherPanel" class="info-panel">ğŸŒ¦ Weather info will appear here.</div>
    <div id="achievementPanel" class="info-panel">ğŸ… Achievements will appear here.</div>
  </div>

  <!-- Prank music audio element -->
  <audio id="prankAudio" loop>
    <source src="https://cdn.pixabay.com/download/audio/2022/03/23/audio_3f6e7b49e0.mp3?filename=fun-funky-ambient-116963.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    let currentMode = 'driving';
    let waypoints = []; // {latlng, marker}
    let polyLayers = [];
    // Flicker badge colors and shake wildly on hover
document.querySelectorAll('.badge').forEach(badge => {
  badge.addEventListener('mouseenter', () => {
    const flicker = setInterval(() => {
      badge.style.borderColor = `hsl(${Math.random()*360}, 100%, 50%)`;
      badge.style.boxShadow = `0 0 20px 5px hsl(${Math.random()*360}, 100%, 70%)`;
      badge.style.transform = `rotate(${(Math.random()-0.5)*30}deg) scale(${1 + Math.random()*0.3}) translate(${(Math.random()-0.5)*10}px, ${(Math.random()-0.5)*10}px)`;
    }, 50);
    badge.flickerInterval = flicker;
  });
  badge.addEventListener('mouseleave', () => {
    clearInterval(badge.flickerInterval);
    badge.style.borderColor = '';
    badge.style.boxShadow = '';
    badge.style.transform = '';
  });
});

// Randomly swap badges positions every 10 seconds
setInterval(() => {
  const container = document.getElementById('badgeContainer');
  const badges = [...container.children];
  for(let i=0; i<badges.length; i++) {
    const swapWith = Math.floor(Math.random()*badges.length);
    container.insertBefore(badges[swapWith], badges[i]);
  }
}, 10000);

// UFO abduction effect on random badge every 20 seconds
function abductBadge() {
  const badges = document.querySelectorAll('.badge:not(.locked)');
  if (badges.length === 0) return;
  const badge = badges[Math.floor(Math.random()*badges.length)];
  const ufo = document.createElement('div');
  ufo.textContent = 'ğŸ›¸';
  ufo.style.position = 'fixed';
  ufo.style.fontSize = '3rem';
  ufo.style.top = '10%';
  ufo.style.left = '-50px';
  ufo.style.zIndex = 9999;
  document.body.appendChild(ufo);

  let left = -50;
  const interval = setInterval(() => {
    left += 20;
    ufo.style.left = left + 'px';
    if (left > window.innerWidth) {
      clearInterval(interval);
      document.body.removeChild(ufo);
      // "Abduct" the badge (hide it for a moment)
      badge.style.visibility = 'hidden';
      setTimeout(() => badge.style.visibility = 'visible', 3000);
      alert('ğŸš¨ Warning: Badge abducted by aliens! ğŸ‘½');
    }
  }, 50);
}
setInterval(abductBadge, 20000);

// Flash background colors randomly like a rave party
setInterval(() => {
  document.body.style.background = `linear-gradient(135deg, hsl(${Math.random()*360}, 100%, 50%), hsl(${Math.random()*360}, 100%, 50%), hsl(${Math.random()*360}, 100%, 50%), hsl(${Math.random()*360}, 100%, 50%))`;
}, 2000);

    // On page load, check if a saved route was loaded from history page
const savedRouteStr = sessionStorage.getItem('routeToLoad');
if (savedRouteStr) {
  const savedRoute = JSON.parse(savedRouteStr);
  sessionStorage.removeItem('routeToLoad');

  // Clear current waypoints
  waypoints.forEach(wp => map.removeLayer(wp.marker));
  waypoints = [];

  // Add start and destination waypoints from saved route
  addWaypoint(L.latLng(savedRoute.start[0], savedRoute.start[1]));
  addWaypoint(L.latLng(savedRoute.destination[0], savedRoute.destination[1]));

  // Set current travel mode
  currentMode = savedRoute.mode;
  document.getElementById('multiModePanel').innerHTML = `<b>${currentMode.toUpperCase()} mode selected.</b> Click "ğŸ¯ Prank Route" or add waypoints on the map to see the results.`;

  updateRoute();
}

    function setMode(mode) {
      currentMode = mode;
      document.getElementById('multiModePanel').innerHTML = `<b>${mode.toUpperCase()} mode selected.</b> Click "ğŸ¯ Prank Route" or add waypoints on the map to see the results.`;
    }

    if (!localStorage.getItem('wrongmapsUser')) {
      window.location.href = 'login.html';
    } else {
      document.getElementById("username").innerText = localStorage.getItem('wrongmapsUser');
    }

    const map = L.map('map').setView([28.6139,77.2090], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

    // Parse lat,lng from string
    function parseLatLng(s) {
      if (!s) return null;
      const [lat, lng] = s.split(',').map(x => parseFloat(x.trim()));
      return (isNaN(lat) || isNaN(lng)) ? null : [lat, lng];
    }

    async function geocodePlace(placeName) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(placeName)}`;
      const res = await fetch(url);
      const data = await res.json();
      if (data.length === 0) throw new Error(`No results for "${placeName}"`);
      return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
    }

    // Add waypoint with draggable marker
    function addWaypoint(latlng) {
      const marker = L.marker(latlng, { draggable: true }).addTo(map);
      waypoints.push({ latlng, marker });

      marker.on('dragend', () => {
        updateWaypointPosition(marker);
        updateRoute();
      });

      marker.on('click', () => {
        removeWaypoint(marker);
        updateRoute();
      });
      updateRoute();
    }

    function updateWaypointPosition(marker) {
      const wp = waypoints.find(wp => wp.marker === marker);
      if (wp) wp.latlng = marker.getLatLng();
    }

    function removeWaypoint(marker) {
      const index = waypoints.findIndex(wp => wp.marker === marker);
      if (index !== -1) {
        map.removeLayer(waypoints[index].marker);
        waypoints.splice(index, 1);
      }
    }

    // Generate wrong destination offset for prank
    function getWrongDestination(originalDest) {
      const offsetLat = (Math.random() - 0.5) * 2;
      const offsetLng = (Math.random() - 0.5) * 2;
      return [originalDest[0] + offsetLat, originalDest[1] + offsetLng];
    }

    // Fetch routes from OSRM API (multi-waypoint supported)
    async function fetchRouteMultiMode(points, mode) {
      if (mode === 'train') {
        // Fake train calculation for multi-waypoints
        const fakeDuration = Math.floor(Math.random() * 5) + 6; // hours
        const fakeDistance = Math.floor(Math.random() * 800) + 200; // km
        return {
          fake: true,
          duration: fakeDuration * 3600,
          distance: fakeDistance * 1000,
          geometry: null
        };
      }
      if (points.length < 2) throw new Error("Add at least 2 waypoints for routing.");

      const coordsStr = points.map(p => `${p[1]},${p[0]}`).join(';');
      const url = `https://router.project-osrm.org/route/v1/${mode}/${coordsStr}?overview=full&geometries=geojson`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Routing service error for ${mode}`);
      const data = await res.json();
      return {
        fake: false,
        duration: data.routes[0].duration,
        distance: data.routes[0].distance,
        geometry: data.routes[0].geometry
      };
    }

    // Draw route polyline on map
    function drawRoute(data) {
      polyLayers.forEach(l => map.removeLayer(l));
      polyLayers = [];
      if (!data.geometry) return;
      const coords = data.geometry.coordinates.map(c => [c[1], c[0]]);
      const poly = L.polyline(coords, { color: 'red', weight: 5, dashArray: '10, 10' }).addTo(map);
      polyLayers.push(poly);
      map.fitBounds(poly.getBounds());
    }

    // Update trip summary panel
    function updateTripSummary(route, destName) {
  // Duration in absurd units
  const totalSeconds = route.duration; // in seconds
  const absurdTimeMs = totalSeconds * 1000;
  const fakeParsecs = (totalSeconds / 3600) * 0.000000001;

  // Distance
  const distanceKm = (route.distance / 1000).toFixed(1);

  document.getElementById('tripSummary').innerHTML =
    `<b>Trip Summary:</b> ${absurdTimeMs.toLocaleString()} milliseconds ` +
    `(${fakeParsecs.toFixed(9)} parsecs) â€” Distance: ${distanceKm} km` +
    `<br><b>Heading to:</b> ${destName}`;

  fakeProgress();
}



    // Show fake navigation steps
    function showFakeNavigation() {
      const messages = [
        "In 40m, turn left into a lake.",
        "Continue straight for 1,342 km.",
        "Stop for coffee at the next roundabout.",
        "Turn rightâ€¦ eventually.",
        "Make a U-turn and question your life choices.",
        "Proceed until you see a cow, then turn left.",
        "You have arrivedâ€¦ probably.",
        "Drive through the shopping mall, it's faster."
      ];
      let steps = [];
      for (let i = 0; i < 5; i++) { 
        steps.push(messages[Math.floor(Math.random() * messages.length)]); 
      }
      document.getElementById('navPanel').innerHTML = steps.join("<br>");
    }
    function saveCurrentRoute() {
  if (waypoints.length < 2) return;
  const start = [waypoints[0].latlng.lat, waypoints[0].latlng.lng];
  const destination = [waypoints[waypoints.length - 1].latlng.lat, waypoints[waypoints.length - 1].latlng.lng];
  const timestamp = Date.now();

  const routes = JSON.parse(localStorage.getItem('wrongmapsSavedRoutes')) || [];
  routes.push({ start, destination, mode: currentMode, timestamp });
  localStorage.setItem('wrongmapsSavedRoutes', JSON.stringify(routes));
}

   
    // Fake progress bar animation
    function fakeProgress() {
      let progress = 0;
      const bar = document.getElementById('routeProgress');
      bar.style.width = "0%";
      const interval = setInterval(() => {
        if (progress >= 100) { clearInterval(interval); }
        progress += Math.floor(Math.random() * 5) + 1;
        bar.style.width = Math.min(progress, 100) + "%";
      }, 500);
    }

    function showFakeTraffic() {
      const alerts = [
        "ğŸš§ Heavy snail traffic ahead.",
        "ğŸ¦† Ducks crossing â€” expect 45 min delay.",
        "ğŸ”¥ Road on fire â€” scenic detour.",
        "ğŸ’ƒ Flash mob blocking main street.",
        "ğŸ˜ Elephant parade in progress.",
        "ğŸ“¸ Speed camera ahead â€” smile!"
      ];
      document.getElementById('trafficPanel').innerHTML = alerts[Math.floor(Math.random() * alerts.length)];
    }

    function showFakePOIs() {
      const pois = [
        "World's Largest Pothole",
        "Statue of a Guy Eating Noodles",
        "Haunted Restroom",
        "Invisible Bridge",
        "The Great Sandpit"
      ];
      let list = "";
      for (let i = 0; i < 3; i++) { 
        list += `â€¢ ${pois[Math.floor(Math.random() * pois.length)]}<br>`; 
      }
      document.getElementById('poiPanel').innerHTML = list;
    }

    function showFakeWeather() {
      const weather = [
        "â˜€ Sunny, 35Â°C",
        "ğŸŒ§ Heavy rain, 12Â°C",
        "â›ˆ Thunderstorm, 20Â°C",
        "â„ Snowstorm, -5Â°C",
        "ğŸŒª Tornado Watch"
      ];
      document.getElementById('weatherPanel').innerHTML = `<b>Weather at Destination:</b> ${weather[Math.floor(Math.random() * weather.length)]}`;
    }

    function showAchievements() {
      const badges = [
        "ğŸ† Master of Wrong Turns",
        "ğŸ¥‡ Lost in Style",
        "ğŸš¦ Red Light Runner (in dreams)",
        "ğŸ—º Route Rebel"
      ];
      document.getElementById('achievementPanel').innerHTML = `<b>Driver Achievements:</b><br>${badges[Math.floor(Math.random() * badges.length)]}`;
    }

    // Map click to add waypoint
    map.on('click', (e) => {
      addWaypoint(e.latlng);
    });

    const prankAudio = document.getElementById('prankAudio');

    // Main route button click â€” parses inputs and sets waypoints start+dest + plays prank music
    document.getElementById('routeBtn').addEventListener('click', async () => {
      try {
        // Stop music and reset progress if already playing, then start new route and music
        prankAudio.pause();
        prankAudio.currentTime = 0;

        // Clear existing waypoints first
        waypoints.forEach(wp => map.removeLayer(wp.marker));
        waypoints = [];

        let startCoords = parseLatLng(document.getElementById('start').value.trim());
        if (!startCoords) startCoords = await geocodePlace(document.getElementById('start').value.trim());

        let destCoords = parseLatLng(document.getElementById('dest').value.trim());
        if (!destCoords) destCoords = await geocodePlace(document.getElementById('dest').value.trim());

        // Apply prank offset on destination
        destCoords = getWrongDestination(destCoords);

        // Add start and prank destination waypoints
        addWaypoint(L.latLng(startCoords[0], startCoords[1]));
        addWaypoint(L.latLng(destCoords[0], destCoords[1]));

        // Route will auto-update because addWaypoint calls updateRoute()

        // Play prank music
        prankAudio.play().catch(() => {
          console.log("Autoplay prevented; user interaction required to play sound.");
        });
      } catch (err) {
        alert(err.message);
      }
    });

    // Update the route based on current waypoints and mode
    async function updateRoute() {
  if (waypoints.length < 2) {
    document.getElementById('tripSummary').innerHTML = '<b>Trip Summary:</b> Add at least 2 waypoints.';
    polyLayers.forEach(l => map.removeLayer(l));
    polyLayers = [];
    return;
  }

  const points = waypoints.map(wp => [wp.latlng.lat, wp.latlng.lng]);

  try {
    const routeData = await fetchRouteMultiMode(points, currentMode);

    // Reverse geocode the final destination for name
    const lastPoint = points[points.length - 1];
    let destinationName = "Your Custom Route";

    try {
      const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lastPoint[0]}&lon=${lastPoint[1]}&format=json`);
      const data = await res.json();
      destinationName = data.display_name || destinationName;
    } catch (geoErr) {
      console.warn("Reverse geocode failed:", geoErr);
    }

    drawRoute(routeData);
    updateTripSummary(routeData, destinationName); // âœ… Use real place name
    showFakeNavigation();
    showFakeTraffic();
    showFakePOIs();
    showFakeWeather();
    showAchievements();
    saveCurrentRoute();
  } catch (err) {
    alert(err.message);
  }
}

    // Apply saved dark mode setting on page load
(function() {
  const darkModeSetting = localStorage.getItem('darkMode');
  if (darkModeSetting === 'enabled') {
    document.body.classList.add('theme-dark');
  } else {
    document.body.classList.remove('theme-dark');
  }
})();


  </script>
  
</body>
</html>
